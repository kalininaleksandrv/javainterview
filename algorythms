Алгоритмы

Алгоритмическая сложность
HashMap добавление, удаление: средний O(1) худший О(n)
ArrayList добавление лучший O(1) худший O(n)
TreeMap среднее O(N log (n))
Красно черное дерево отличается от обычного тем, что балансирует идущие подряд элементы. Бинарное дерево если в него подать обратную последовательность выродится в связанный список а черно красное все равно станет деревом.

O(1)
Устойчивое время работы не зависит от размера задачи
Ожидаемое время поиска в хеш-таблице
O(log log n)
Очень медленный рост необходимого времени
Ожидаемое время работы интерполирующего поиска n элементов
O(log n)
Логарифмический рост — удвоение размера задачи увеличивает время работы на постоянную величину
Вычисление xn; Двоичный поиск в массиве из n элементов
O(n)
Линейный рост — удвоение размера задачи удвоит и необходимое время
Сложение/вычитание чисел из n цифр; Линейный поиск в массиве из n элементов
O(n log n)
Линеаритмичный рост — удвоение размера задачи увеличит необходимое время чуть более, чем вдвое
Сортировка слиянием или кучей n элементов; нижняя граница сортировки сопоставлением n элементов
O(n²)
Квадратичный рост — удвоение размера задачи увеличивает необходимое время в четыре раза
Элементарные алгоритмы сортировки
O(n³)
Кубичный рост — удвоение размера задачи увеличивает необходимое время в восемь раз
Обычное умножение матриц
O(cn)
Экспоненциальный рост — увеличение размера задачи на 1 приводит к c-кратному увеличению необходимого времени; удвоение размера задачи увеличивает необходимое время в квадрат
Некоторые задачи коммивояжёра, алгоритмы поиска полным перебором

SOLID:
	1. 
Single Responsibility Principle (Принцип единственной ответственности).
	2. 
Open Closed Principle (Принцип открытости/закрытости).
	3. 
Liskov’s Substitution Principle (Принцип подстановки Барбары Лисков).
	4. 
Interface Segregation Principle (Принцип разделения интерфейса).
	5. 
Dependency Inversion Principle (Принцип инверсии зависимостей).

