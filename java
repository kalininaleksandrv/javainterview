CoreJava
какие в java бывают типы - ответ  примитивные и ссылочные
как в java передаются объекты в функцию - по ссылке или по значению - ответ по ссылке (в стэке ссылка на объект в хипе)
отличия абстрактного класса от  интерфейса
	* 
в абстрактном классе есть реализация методов
	* 
можно отнаследоваться только от одного класса но имплементировать много интерфейсов
	* 
в java 8 в интерфейс добавились дефолтные методы у них есть реализация


как создать класс java - вызвать new или вызвать через рефлексию конструктор класса

Объект Б наследуется от суперкласса А, в каком порядке будут вызываться методы и конструктуры А и Б если мы создаем объект Б? - сначала инициализируется класс А, потом создастся объект Б, потом будут вызываться методы, если они вызываюся явно. 
Будет ли вызван метод А если в конструкторе А он вызывается а при создании Б он не вызывается? Если в конструкторе А вызывается метод класса а, то будет ошибка "нет такого метода" т.е. объект А не создается. 

модификаторы доступа - private, package private (установлен по умолчанию, это протектед минус наследование), protected, public

Чем переопределение (overriding) отличается от пергрузки (overloading) и что у них общего
Overriding это создание конкретной реализации у метода интерфейса или аьстрактного класса, overloafing это несколько методов с одинаковыми названиями но разными условиями выполнения например по типу входящей переменной
Общее - это примеры полиморфизма т.е. изменения поведения программы в момент исполнения

Что может быть обьявлено как final - класс, метод, переменная
final в классе запрещает наследование
final в методе запрещает переопределение

Зачем нужны static переменные и блоки - они инициализируются до конструктора класса
static class можно объявить только внутри обычного класса
в статическом внутреннем классе нет ссылки на внешний класс, а в обычном есть

как из внутреннего класса получить доступ к полям внешнего класса - из обычного через this из статического - создать экземпляр внешнего класса

static - можно обращаться к переменным и методам класса без создания обьекта
если изменить static переменную то она изменится у всех экземпляров класса
Статические методы не могут обращаться к нестатическим членам
Статические методы используются для инициализации статичных переменных
если в наследуемом классе переопределить статический метод суперкласса то будет вызван метод суперкласса тк статик значит не в рантайм а в компайлтайм

Чем final отличается от static - final означает что переменная не будет меняться после обьявления, static что переменная имеет только один экземпляр в текущем потоке

если equals true то хэшкоды равны, но если кэшкоды равны не обязательно иквалс тру может просто метод плохо переопределен
Может ли equals быть true у разных объектов если hashcode переопределен правильно? Может, но очень редко hashcode имеет ограниченное количество и если объектов больше то у каких-то hashcode соваадет
если хэшод элемента поменялся его не получится найти в структурах зависимых от хэша - хэшсете например тк в хэшмэп зависим от ключа а не значения
чтобы включить коллекцию в составе объекта в хэш, нужно, чтобы она была неизменяемой
чтобы создать неизменяемую коллекцию в классе, нужно на этапе создания объекта через конструктор скопировать ее
метод compareTo должен возвращать 0 если объекты equals=true или -1/1 если объект больше или меньше
этот метод нужен алгоритмам сортировки и коллекциям
Comparable и Comparator это интерфейсы, comparable поддерживает естественный порядок сортировки, например в классах обертках Integer и Long, Comparator сортирует в порядке определенном пользователем (возвращая 0/1/-1)
comparable используем как реализацию интерфейса объектом если сравнение одно и если есть доступ к объекту, если сравнивать нужно по разному или нет возможности расширить класс то можно использовать объект comparator

synchronized переменная - означает что доступ к ней возможен только из одного потока в каждый момент времени
synchronized может быть метод и блок кода, если блок кода в него надо передать объект на котором синхронизируемся, syncronized перед методом это все равно что в syncronized блока передать this т.е. синхронизация на классе метода
если метод статический то место this надо явно передать Myclass.class
synchronized используется при создании singleton
synchronized реализован через объект monitor

volatile - значение этой переменной может изменяться другими потоками - в каждом потоке создается копия, которая ссылается на настоящую переменную. чтение volatile-переменной и запись в volatile-переменную синхронизированы, а неатомарные операции ― нет. Это означает, что следующий код не является потокобезопасным: myVolatileVar++;

Виды ссылок java: 
	* 
обычные, гц удаляет обьект только если их нет
	* 
weak, гц удаляет обьект даже если они есть
	* 
soft, гц удаляет обьект если они есть но имеется критическая нехватка памяти
	* 
phantom, гц удаляет обьект в любой момент но обьект не будет удален из памяти пока не будет удалена или очищена фантомная ссылка



Чтобы защитить объект от изменения полностью не делая его static нужно
	* 
убрать сеттеры
	* 
сделать переменные final
	* 
если есть вложенные объекты то в конструкторе не присваивать поле напрямую, а копировать



Методы класса Object
equals
hashcode
getClass
toString
Wait/notify/notifyAll

Что такое assert в java - это оператор который проверяет утверждение и генерирует исключение если оно ложно

Строки - как сравнивать? Сравнение по equals более правильная но более дорогая операция, сравнение по == возможно если строка есть в пуле интернированных строк, для строки созданной через билдер такое сравнение не корректно
"123" == "123"                          // true
("12" + "3").intern() == "123"          // true
new String("123") == new String("123")  // false
new String("123") == "123"              // false
new String("123").intern() == "123"     // true

Разница между stringbuffer и stringbuilder - первый синхронизирован, второй нет
Зачем их использовать - в java строки неизменяемый объект и проводить добавление подстрок в сроки дорого, а stringbuffer и stringbuilder  изменяемые обьекты.
Наоборот если нужно выделить прдстроку из строки то нужно использовать String т.к. не выделяется новый массив.

Какие бывают потоки ввода вывода в java: байтовый (inputStream и outputStream) и символьный (reader, writer) 
это абстрактные классы которым можно добавлять функциональность например 
FileInputStream fin=new FileInputStream("C://SomeDir//notes.txt")

Java Memory Model

что такое Heap и Stack, чем они отличаются? heap это область памяти которая создается при начале работы jvm, она общая и объекты которые в ней находятся доступны для любой части программы, в heap работает garbag collector удаляя объекты на которые нет ссылок
stack это локальная память для методов и переменных методов, работает по принципу lifo, освобождается когда метод закончил работу, гораздо меньше heap
в stack хранятся значения примитивных типов и ссылки на другие объекты в методе 
как только метод заканчивает работу, его stack также перестает использоваться
когда мы создаем в методе новый объект, то он появляется в Heap а в Stack метода появляется на него ссылка
когда мы из метода вызываем другой метод на вершине стека появляется блок, который принадлежит этому методу
если вызывая метод мы передали ему в качестве параметра объект то в его блоке появится ссылка на этот объект
если в методе создается строка то она передается в Heap в пул строк а в стеке появляется ссылка 

Collections
Разница между HashMap и HashTable в Java:
	* 
HashTable потокобезопасна, а HashMap нет
	* 
HashTable не может содержать элементы null,


Разница между Iterator и ListIterator
	* 
ListIterator только доя List, а Iterator для set и map 
	* 
Lisriterator двунаправленный
	* 
Listiterator имеет методы для добавления и удаления данных во время итерирования



HashMap ищет по ключу, а не по значению. В HashMap в качестве значений хранятся ссылки на обьекты, в HashSet хранится специальный класс, в остальном это похожие структуры
TreeSet отличается от TreeMap тем что они реализуют разные интерфейсы и еще тем что в тримап сортированы ключи а в трисет сами объекты
TreeSet это интерфейс реализующий SortedSet
Если убирать из ArrayList значения, он не меняется в размере. Только через метод трим ту сайз
количество имплементаций коллекций увеличивается в пакетах copyonwrite, concurent, unmodyfiable
чтобы положить класс в SET он должен implements comparable или нужно предоставить компаратор
Collections.unmodifiable - сделает коллекцию неизменяемой
Collections.syncronized - сделает коллекцию потокобезопасной
Итератор fail-fast вызывает исключение сразу как обнаружит что структура коллекции была изменена после начала перебора
Итераторы fail-safe не вызывают никаких исключений при изменении структуры, потому что они работают с клоном коллекции вместо оригинала. Итератор коллекции CopyOnWriteArrayList и итератор представления keySet коллекции ConcurrentHashMap являются примерами итераторов fail-safe
Что такое BlockingQueue? Это очередь, которая позволяет обрабатывать ситуации, когда из пустой очереди пытаются получить элемент, или когда пытаются добавить элемент в очередь, а место в ней закончилось.
Чем HashMap отличается от TreeMap - treemap автоматически сортирует помещенные в нее значения
Когда нужно использовать TreeMap - когда данные нужно хранить или обрабатывать в уже отсортированном виде
В каком случае HashMap сильно пооседает по производительности - если у объекта неправильно реализован метод hashcode() то HashMap выродится в связанный список

Иерархия исключений - исключения идут от абстрактного класса Trowable и делятся на Error и Exception, Exception бывают runtime и не рантайм. Ерроры и рантайм эксепшены - unchecked, остальные checked
если исключение выкинулось в catch или finaly то оно подавит первое произошедшее исключение, но его все еще можно получить через Exception.getSupressed НО в контрукции трай с ресурсами не подавит
Если в finaly возникло исключение то на этом работа блока будет завершена т.е. нет гарантии полного выполнения кода в  finaly

Многопоточность
Что такое Callable - это интерфейс как Runnable для вычисления в другом потоке Callable подобен Runnable, но с возвратом значения. Интерфейс Callable является параметризованным типом, с единственным общедоступным методом call().
Что такое Future - Future хранит результат асинхронного вычисления. Вы можете запустить вычисление, предоставив кому-либо объект Future, и забыть о нем. Владелец объекта Future может получить результат, когда он будет готов.
Как реализовать future и callable в реальной задаче - нужно создать обьект имплементирующий callable, реализовать метод call и передать его в реализацию FutureTask - обьекта имплементирующего Future и Runnable

Spring

скоуп бина по умолчанию Singleton, это значит что бин будет создан до метода getBean и всем будет возвращаться 1 экземпляр бина
бины предоставляемые через синглтон должны быть стейтлесс т.е не иметь состояния которое может изменяться из кода
скоуп Prorotype - каждый раз создается новый объект

для управления транзакциями используется аннотация @Transactional
для нее указывается степень изоляции, например isolation=Propagation.REQUIRED
* Propagation.REQUIRED — применяется по умолчанию. При входе в @Transactional метод будет использована уже существующая транзакция или создана новая транзакция, если никакой ещё нет
* Propagation.REQUIRES_NEW — второе по распространённости правило. Транзакция всегда создаётся при входе метод с Propagation.REQUIRES_NEW, ранее созданные транзакции приостанавливаются до момента возврата из метода.
*Propagation.MANDATORY — обратный по отношению к Propagation.REQUIRES_NEW: всегда используется существующая транзакция и кидается исключение, если текущей транзакции нет.
есть еще несколько
если вызвать метод @Transactional requires new из другого метода @Transactiinal в том же классе, то транзакция не откроется, это потому что спринг подменяет наши объекты их прокси-объектами чтобы добавить @Transactional функциональность а при вызове напрямую внутри класса этого не происходит

бин спринга отличается от обычного обьекта тем, что управляется аппликейшен контекстом, бин проходит через жизненный цикл - запуск спринг приложения - создание спринг контейнера - создание объекта бина - внедрение зависимостей - вызов указанного init() метода - использование бина - вызов destroy метода
init и destroy методы 
	* 
могут называться как угодно
	* 
любые модификаторы доступа
	* 
любой тип возвращаемого значения но его получить нельзя тч лучше  void
	* 
не должны иметь параметров (аргументов)


у бинов со скоупом protitype не вызывается destroy метод
даже если бин создается спрингом не через new а через factoryMethod, паттерн синглтон все равно будет работать
аннотация @PostConstruct аналогична init методу но init может быть только 1 а postconstruct сколько угодно
@PostConstruct поддерживается в интерфейсах если указан над default методом 

если в @Configuration указать bean определенного типа или листа таких типов а в сервисе указать лист таких типов с @Autowired то в это поле сервиса заинжектятся все бины данного типа из @Configuration 

если в контейнере есть 2 бина наследника одного класса а мы пытаемся заинжектить класс-родитель спринг не поймет какой мин инжектить и упадет с ошибкой, но можно явно указать ему бин: добавляем аннотацию @Qualifier над бином и добавляем @Название_бина 

jpa это стандарт а hibernate его реализация
Требования к Entity
1) Entity класс должен быть отмечен аннотацией Entity или описан в XML файле конфигурации JPA,
2) Entity класс должен содержать public или protected конструктор без аргументов (он также может иметь конструкторы с аргументами),
3) Entity класс должен быть классом верхнего уровня (top-level class),
4) Entity класс не может быть enum или интерфейсом,
5) Entity класс не может быть финальным классом (final class),
6) Entity класс не может содержать финальные поля или методы, если они участвуют в маппинге (persistent final methods or persistent final instance variables)

JavaEE

JSP
у бина в jsp могут быть скоупы session, reqwest, application (session от reqwest отличается тем, что последний может быть задействован на нескольких страницах в рамках одного запроса, application кладется в context приложения
у сервлета есть жизненный цикл - init() -> service() -> destroy(), в jsp аналогичные методы jspInit, jspDestroy

EJB
Сервер приложений j2ee состоит из двух основных элементов: контейнер web-приложения (JSP, JSF и т.д.) и EJB-контейнер. Первый служит для создания пользовательского интерфейса и слабо подходит для описания бизнес-логики приложения. Для этого используется вторая часть J2EE - EJB.
Существует три типа компонентов EJB:
1. session beans - используется для описания бизнесс-логики приложения
2. message-driven beans - так же используется для бизнесс-логики
3. entities - используется для хранения данных

Session beans - Существует 2 типа session-beans: stateless и stateful. Stateful-бины автоматически сохраняют свое состояние между разными клиентскими вызовами. Типичным примером stateful-бина является корзина в интернет-магазине. Stateless-бины используются для реализации бизнесс-процессов, которые могут быть завершены за одну операцию.Так же на основе stateless-бинов проектируются web-сервиса.
Message-driven beans Так же как и session beans используются для бизнесс-логики. Отличие в том, что клиенты никогда не вызывают MDB напрямую. Обычно сервер использует MDB в асинхронных запросах.
У stateless и MDB бинов существует 2 события жизненного цикла, которые мы можем перехватить: создание и удаление бина. Метод, который будет вызываться сразу после создании бина помечается аннотацией javax.annotation.PostConstruct, а перед его удалением - javax.annotation.PreDestroy. Stateful бины обладают помимо рассмотреных выше еще 2 событиями: при активации (javax.ejb.PostActivate) и при деактивации (javax.ejb.PrePassivate).
