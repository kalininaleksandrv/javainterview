ANDROID
Общее

Андроид приложение состоит из исполняемого кода, ресурсов и манифеста
Манифест это файл-дескриптор которым приложение сообщает фреймворку из чего оно состоит
В манифесте указываются
	* 
Имя пакета
	* 
Компайл, мин, таргет сдк
	* 
Сервисы, бродкаст ресиверы, контент провайдеры
	* 
Пермишены
	* 
Аппликейшен
	* 
Активити
	* 
Интент-фильтры


Программа может выполняться в нескольких процессах. В каждом из процессов может быть создано несколько потоков (Java Threads).

Компиляция
MinSDK - минимальная версия на которой работает
CompileSDK - версия sdk которой скомпилировано приложение
TargetSDK - версия sdk на которую нацелено приложение

Запуск
Android делает clone с со своего главного потока (зиготу) далее в нем:
приложение дергает метод main, который находится в самом андроиде
далее инициализируется Application там метод onCreate
далее Application запускает нужный компонент
далее запускается main thread

Приоритеты процессов от самого приоритетного
1 есть активити в онРезьюм т.е. в фокусе пользователя или сервис который приконнектился к этой активити (колбэки onCreate(), onStart(), onDestroy()) или активный бродкаст ресивер в состоянии он ресив
2 активити в онПауз т.е. еще на экране но не взаимодействуем а также сервисы этой активити  запущеные через Service.startForeground()
3 сервис в состоянии startService()
4. Закэшированный процесс. К ним относятся пустые процессы, используемые при старте приложений, и процессы, в которых все активити в onStop() состоянии.
https://developer.android.com/guide/components/activities/process-lifecycle



Activity
можно делать сингл активити если побороть сайдэфекты
дополнительные активити можно делать  - если есть несколько точек входа в приложение - если активити ест много памяти разделить чтобы система грохнула 2ю активити а не основную - если нужно чтобы часть приложения реализовывала другую логику onConfigurationChange
Запуск активити можно сделать из другого приложения через отправку в систему intent, метод startActivity или startActivityForResult с коллбэком результата работы активити
intent объявляется в манифесте в разделе интент-фильтр, там указываем системе что может наше конкретное активити т.е. когда его предлагать пользователю
в манифесте можно обьявить режим запуска активити со стороны запускаемого приложения а также через флаг запуска со стороны запускающего приложения 
standart aka multiple - активити существует во множесте тасков, 
singleTop - активити существует только на верху стэка, 
singleTask - активити только в единственном экземпляре,
singleInstance - только для лаунчеров
Предположим, что стек переходов назад задачи состоит из корневой операции A с операциями B, C и D на вершине (стек имеет вид A-B-C-D и D находится на вершине). Поступает намерение для операции типа D. Если D имеет режим запуска "standard" по умолчанию, запускается новый экземпляр класса и стек принимает вид A-B-C-D-D. Однако, если D имеет режим запуска "singleTop", существующий экземпляр D получает намерение через onNewIntent(), так как этот экземпляр находится на вершине стека — стек сохраняет вид A-B-C-D. Однако, если поступает намерение для операции типа B, тогда в стек добавляется новый экземпляр B, даже если он имеет режим запуска "singleTop".
ВСЕ ЭТО ЧТОБЫ СОЗДАТЬ БЭКСТЭК ТЕ ЧТОБЫ ПОЛЬЗОВАТЕЛЬ МОГ ПЕРЕМЕЩАТЬСЯ ЧЕРЕЗ КЛАВИШУ НАЗАД

Fragments
Fragment используется для отображения части UI на экране. Фрагмент создается внутри активити или внутри другого фрагмента.
Для создания и управления фрагментами используется FragmentManager.
Класс-наследник класса Fragment должен иметь дефолтный конструктор без параметров. Система использует этот конструктор при пересоздании фрагмента.
Начиная с API v28 системный класс Fragment – deprecated. Рекомендуется использовать Fragment из Support Library.
Для управления фрагментами используются два класса: FragmentManager и FragmentTransaction.
Для получения FragmentManager используются метод активити getSupportFragmentManager() или метод фрагмента getChildFragmentManager().
FragmentManager начинает транзакцию и возвращает объект FragmentTransaction вызовом метода beginTransaction().
Методы класса FragmentTransaction, которые необходимо знать - add(), remove() и replace().
add() добавляет фрагмент на активити или другой фрагмент. Принимает аргументами containerViewId, в который добавляется фрагмент, инстанс фрагмента, тег.
Другой способ добавить фрагмент - определить в лэйауте с помощью тега <fragment>.
remove() - операция, обратная add(). Удаляет фрагмент.
replace() удаляет все фрагменты, добавленные методом add() в заданный контейнер, и добавляет переданный аргументом фрагмент в контейнер. Параметр tag может быть null.
Эти операции не выполняются сразу же после вызова методов. Метод commit() завершает транзакцию и выполняет операции транзакции.
Метод addToBackStack() добавляет транзакцию в Back Stack. Это значит, что когда пользователь нажмет Back транзакция откатится. addToBackStack() применяется ко всем операциям в транзакции.
Метод popBackStack() удаляет транзакцию с верхушки бэкстэка, возвращает true, если бэкстэк хранил хотя бы одну транзакцию.
Если несколько фрагментов добавляются в один контейнер, то порядок добавления определяет порядок в котором фрагменты отрисовываются в иерархии view.
Если метод addToBackStack(String name) вызывается несколько раз на одной транзакции, то транзакция добавляется в бэкстэк один раз с тегом, который передается в последнем вызове метода.
Tag в методе add() присваивается фрагменту. Fragment.getTag() возвращает этот тег. Тег фрагмента используется в методе findFragmentByTag(). Tag в методе addToBackStack() это на самом деле не tag, а name. Имя транзакции, которое присваивается объекту BackStackEntry и возвращается методом getName(). нельзя эти 2 тэга делать одинаковыми
метод commit() асинхронный, он добавляет транзакцию в очередь главного потока и транзакция выполняется при первой возможности. Чтобы выполнить транзакцию синхронно, можно воспользоваться методом commitNow()
есть два метода для поиска и получения фрагмента внутри активити: findFragmentByTag() и findFragmentById(), вызываются кажется на фрагмент менеджере который можно получить из контекста, если фрагмент не найден методы возвращают null
жц фрагмента похож на жц активити но добавляются методы Attach-Deattach  onCreateView() – Метод, в котором создается иерархия View, связанная с фрагментом. onActivityCreated() – Вызывается после того, как отрабатывает метод Activity.onCreate().  onDestroyView() – Метод, в котором фрагмент очищает ресурсы, связанные с иерархией View.
Когда фрагмент удаляется методом remove() или replace() и транзакция добавляется в back stack, то у удаленного фрагмента вызывается onStop() и не вызывается onDestroy(). Если пользователь нажимает Back, то транзакция откатывается и у фрагмента вызывается onStart(). Если же транзакция не добавляется в back stack, то у удаленного фрагмента вызывается onDestroy().
Target Fragment используется как способ взаимодействия между фрагментами. Идея аналогична механизму startActivityForResult()  Target fragment лучше колбэка тем, что он переживает configuration changes. Система сама подставляет новый инстанс таргет фрагмента, когда он пересоздается.
DialogFragment – фрагмент, который содержит внутри себя объект Dialog и выступает как интерфейс для взаимодействия с диалогом. У DialogFragment жизненный цикл фрагмента. Система сама заботится о пересоздании DialogFragment при configuration changes

жизненный цикл
можно сохранить данные в Bundle и восстановить в методе onCreate(Bundle savedInstanceState)
Система вызывает onSaveInstanceState() и onRestoreInstanceState() только в том случае, когда необходимо сохранить состояние, например при повороте экрана или при убийстве активити для освобождения памяти. Данные коллбэки не вызываются, если пользователь выходит из активити нажав Back или если активити убивается вызовом finish().
часть view восстанавливается системой, например позиция в тексте или чекбокс
вызовы onStop и onDestroy не гарантируются системой
можно самому пересоздать activity вызвав метод recreate()
если у view нет id она не восстановится после восстановления активити в onCreate
метод onRestoreState вызывается уже ПОСЛЕ onCreate по этому нельзя обращаться к отресторенной вью в onCreate
в Bundle нельзя положить данные которые не Parselable or Serialazeble, а также потоки
Данные можно хранить в RetainFragment

Потоки
1 создаем класс extends Thread, там оверрайдим метод run (super.run), то что внутри выполняется в другом потоке
2 implements runable @override run
поток можно остановить методом interrupt, но фактически нет гарантий что он будет остановлен, потому что останавливать потоки вообще плохая идея, правильно обрабатывать флаг интеррапт в самом потоке и реализовывать остановку из этого потока
уже в этом простейшем случае можно отдать в другой поток выполнение тяжелой задачи и ui на main thread не будет блокирован
но если из этих методов run попробовать вызвать ui / main thread то упадем с эксепшеном
кроме того при подходе через ранабл утекает активити и не обрабатывается жизненный цикл
можно создать handler на main thread и вызвать его метод ран и в нем вернуть результат в ui тк потумолчанию хэндлер создается на лупере того потока где он создан
то есть в бэкграунд потоке вызываем хэндлер и передаем через него сообщение в очередь сообщений главного потока
если создать хэндлер на бэкграунд потоке (и не передать в него main looper) то при попытке вызвать будет исключение тк в потоке не вызывался looper.prepare() looper должен создать для хэндлера message queue для работы
handler самая низкоуровневая, ниже только looper который сам на message queve
asyncTask высокоуровневый, простой, негибкий, preexecute выполняется на вызывающем потоке а postexecute всегда на main
вызов асинктаска на дефолтном экзекьюторе выполняется в общей очереди таких же вызовов, основные минусы а) нельзя обрабатывать ошибки б) чтобы обновить активити нужно держать в асинктаске ссылку на активити (решается через слабые ссылки) в) нельзя один асинктаск запустить 2 раза
основной метод doInBackground, но также можно переопределить преЕкзекьют, постЕкзекьют и прогресс
механизм handler-looper не знает о жизненном цикле и не умеет его обрабатывать
loader - умеет правильно обрабатывать жизненный цикл, лоадеры пришли на смену асинктаскам в апи11
много кода и не очень удобный
rxJava

Loader 
специальный компонент который переживает жизненный цикл activity, соответственно в нем можно делать длинные операции, результат придет в колбэк
в лоадер передается активити но на самом деле там вызывается getApplicationContex т.ч утечки памяти не возникает

Content Provider
он он в системе
дает возможность делиться данными между приложениями
лучше не использовать
позволяет оповещать подписчиков об изменении данных через notifyUriChange

Service
обьявляется в манифесте
Сервисы делятся на два вида по способу использования: Started и Bound, и на два вида по способу взаимодействия с пользователем: Background и Foreground.
сервис это активити без ui НО бывают сервисы с ui - foregroundServise для системы фореграунд сервис значительно приоритетней чем бэкграунд, он будет убит сильно позднее (например музыка с кнопкой плэй в нотификешн баре)
работа в фоне
Started Service Запускается методом startService(Intent intent). Intent должен быть явным (explicit), это значит, что при создании объекта Intent было передано имя класса сервиса. стоп тоже через интент
Bound Service привязывается к компоненту вызовом метода bindService(Intent service, ServiceConnection serviceConnection, int flags). Аргумент serviceConnection используется для взаимодействия с привязанным сервисом. Сервис стартует после вызова bindService(), если аргумент flags имеет значение BIND_AUTO_CREATE.После вызова bindService() у сервиса вызывается метод onBind().Для отвязывания компонента от сервиса используется метод unbindService(). У сервиса вызывается метод onUnbind().Если у сервиса больше нет привязанных компонентов, вызывается метод onDestroy().
Компонент может быть привязан к сервису, запущенному методом startService(). В этом случае сервис относится сразу и к Started и к Bound.
Bound и Started сервисы важно различать, потому что у них разные жизненные циклы.
started: onCreate - onStartComand - onDestroy
bound: onBind - onUnbind - onDestroy
для старта сервиса передается контекст по этому использовать сервис в качестве шины данных плохая идея
то, что делает сервис нельзя сделать лоадером, асинктаском и хэндлером тк они привязаны к активити, а еще будет нельзя обрабатывать ошибки и управлять жизненным циклом
при создании сервиса вызывается onCreate а при повторном обращении только onStartComand
при вызове stopService будет вызван onDestroy, есть метод stopSelf с id и без, если без то убьем все задачи, иначе только задачу по айди
нужно вызвать стопсервис из каждого компонента из которого мы его стартовали чтобы сервис был разрушен
по умолчанию сервис будет делать операцию на главном потоке и блокирует его, по этому для тяжелых операций либо реализовываем многопоточность в онСтартКоманд либо берем intentService, там метод onHandleIntent вместо onStartService
асинхронный способ взаимодействия с сервисом - pendingIntent можно создать от имени сервиса бродкаста или активити и туда и придет результат
синхронный способ - байндинг любой тип данных, метод onUnbind нужно вызвать из всех компонентов чтобы сервис разрушился
еще способ взаимодействия - через broadcast reciever
с Android 8.0, Фоновые сервисы работают пока пользователь взаимодействует с приложением. Система убивает все фоновые сервисы после того, как пользователь покидает приложение. Нельзя запустить фоновый сервис для приложения, с которым не взаимодействует пользователь. Вместо фоновых сервисов рекомендуется использовать JobScheduler или видимые сервисы.

BroadcastReciever
одна из точек входа в приложение
позволяет принимать запросы от других участников системы
запрос делается через sendBroadcast(intent)
можно зарегистрировать бродкастресивер в манифесте и указать интент-фильтр или зарег в контексте. Выполняется методом context.registerReceiver(receiver: BroadcastReceiver, intentFilter: IntentFilter). Этот метод принимает параметром объект класса IntentFilter, который определяет на какие действия будет реагировать ресивер.
Если метод registerReceiver() вызывается на активити, то ресивер будет получать события, пока система не уничтожит активити. Если вызвать registerReceiver() на application context, то ресивер останется зарегистрированным, пока запущено приложение. 
не использовать в качестве шины тк события летают через систему
можно реализовать локальный бродкаст ресивер но это тоже очень неудобно
можно запустить в отдельном потоке но по умолчанию стартует на главном
JobSheduler - позволяет запрограммировать выполнение в зависимости от системных событий и стартовать сервис
Для выполнения фоновых потоков в onReceive() используется метод goAsync(), который сохраняет BroadcastReceiver после завершения onReceive(). Но даже с использованием метода goAsync() жизнь ресивера ограничивается 10 секундами.
Для выполнения действительно длительных операций рекомендуется использовать Foregorund service или JobIntentService, которые можно запустить в onReceive().
способы передачи - обычный, упорядоченный (можно передавать данные от предыдущего к следующему), локальный (только в своем приложении)
упорядоченные броадкасты доставляются в порядке приоритета. Приоритет задается не у самого ресивера, а у объекта IntentFilter. Есть два способа задать приоритет. 1. Статически в манифесте атрибутом priority 2 динамически в коде
Ограничения на броадкасты начали вводить в Android 7, но в 8й версии они стали более строгими и общими. Ограничения касаются приложений с targetSdkVersion = 26.

* Неявные (implicit) броадкасты, зарегистрированные в андроид манифесте, больше не работают (кроме некоторых исключений).

Permissions
устанавливаются в манифесте
можно настроить в одном и использовать в другом своем приложении level=signature
пользователь дает в момент установки или автоматически
можно запрашивать во время выполнения, результат возвращается в callback
в зависимости от версии андроида - например для localstorage при sdk23+ нужно проверять в рантайме и запрашивать во время выполнения там еще дурацкая схема с id и надо обработать отказ а еще пользователь может выбрать больше не показывать
бывают критичные (доступ к смс контактам и тп) и не критичные (установка временной зоны)
sdk<23 запрашивались групповые пермишены т.е давая разрешение на чтение из хранилища пользователь давал разрешение и на запись
если в приложение которое уже в маркете добавить критикал пермишен то пользователь должен будет установить новую версию в ручную
все основные элементы приложения (активити, сервис, провайдер, ресивер) могут быть защищены кастомным пермишеном

res
может провайдить вариативно ресурсы от свойств настроек системы, например отдавать надписи на нужном языке или вьюху в портрете или лэндскейпе
менеджер ресурсов это файл android.R
в R все лежит по сгенерированным ключам, а ключи это int

кроме папки рес есть еще джавовская папка ресурсес и андроидовская папка ассетс для статического контента, оттуда можно прочитать что то через байт стрим например базу данных скопировать
в ассетс могут быть папки а в ресорсез не могут

Graddle
сборка происходит по графу тасков
работает на groovy
graddle wrapper .gradlew позволяет зафиксировать версию сборки и собрать проект не имея греддл на компьютере
обфускацию выполняем через proguard
dex это dalvic executable dalvic это виртуальная машина которая была до 4.4 дальше в.м. ART андроид рантайм
multidex ограничение на количество методов dex file 50000

ADB

adb shell dumpsys - позволяет сдеоать дамп системы
adb shell dumpsys activity activities | grep '*' - можно увидеть запущенные таски и стэки 

Рисование
битмап - растровая графика, канвас - векторная
пэйнт это цвет которым канвас рисует на битмапе

View
От базового класса View наследуется все остальное - ImageView, ViewGroup (это все лэйауты), TextView (напрмер button это textview)
У view есть жизненный цикл: Constructor - onAttachToWindow - mesure - onMesure - layout - onLayout - dispatchDraw - draw - onDraw
вызывая mesure родительский компонент заставляет чайлд компонент измерить себя и отдать ему значение
т.е. измеряются все вью от самой верхней до самой нижней по уровню вложенности
далее методом layout родительский компонент устанавливает необходимые значения чайлд-компонента, располагая его на экране, если родительский компонент это ViewGroup, то нужно переопределить метод onLayout(), чтобы вызывать методы layout чайлд-компонентов
Constraint Layout удобнее всего
forceLayout перерисует все, что ниже по дереву а requestLayout и выше и ниже и его надо избегать
именно по этому надо также избегать большой вложенности
invalidate - метод когда вью нужно перерисовать без изменения размеров (с метода dispatchDraw)
invalidate блокирующий, postinvalidate неблокирующий
requestLayout с метода mesure
чтобы написать кастомную view-group нужно всего 3 шага
layoutParams - определим параметры вью
onMesure - определим механизм изменения размеров
onLayout - определим механизм размещения
60fps = 16милисек

Recycler View
сам ресайклер вью отвечает за взаимодействие с экраном тк это вью и она получает от системы задачу промерить и отрисовать чайлд элементы и делегирует эту задачу лэйаут менеджеру
layout manager размещает и межерит элементы отвечает за фокусинг, есть линеар лэйаут, грид лэйаут и другие
item animator анимирует
adapter создает вьюхи, управляет их количеством, отвечает за касания (клики), переиспользование вьюхолдеров, частичное обновление данных
item decorator дорисовывает элементы, рисует отступы, рисует сзади элементов и т.п.
viewholder отвечает за кжширование finfviewbyid и служит мостом по которому аниматоры и другие модули могут прлучить view id, это основной элемент ресайклинга именно о и должен переиспользоваться в ресайкл вью
	1. 
лэйаутменеджер запрашивает у ресайклера вью для элемента данных getViewForPosition
	2. 
ресайклер пробрасывает запрос в кэш и получает оттуда готовую вью
	3. 
если готовой вью нет, ресайклер идет в адаптер и получает вьютайп
	4. 
ресайклер передает вьютайп в ресайклед пул и получает вьюхолдер нужного типа но с неправильными данными getViewHolderByType
	5. 
если в ресайлед пуле нет нужного вьюхолдера то ресайклер запросит адаптер создать нужную вью и получит ее
	6. 
когда вью создана лэйаут менеджер через ресайклер уведомляет об этом адаптер
	7. 
после того как вью перестала использоваться лэйаут менеджер уведомляет об этом ресайклер
	8. 
если вью валидна те может быть использована позднее для этой же позиции, ресайклер передает ее в кэш, кэш передает устаревшие вьюхи в пул, а пул уведомляет адаптер что вью перемещена в пул и ее надо очистить например
	9. 
если вью не валидна то сразу в ресайклер пул


used getAdapterPosition to bind data and used getLayoutPosition to tell the user the position of the pressed item
itemTouchHelper позволяет из коробки делать swipe-to-dismiss и dragAndDrop
